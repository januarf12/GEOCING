##############################################################################################################################
#----------------------------------------------BLOQUE #1---------------------------------------------------------------------#
##############################################################################################################################

# -*- coding: utf-8 -*-
# ---------------------------------------------------------------------------
# Generacion de Perfiles por laderas
# Created on: 2020-12-11 14:24:34
#   (generated by ArcGIS/ModelBuilder)
# Usage: Generacion de perfiles para laderas a fin de aplicar la metodológia del talud infinito en calculos de susc. ante MM
# Description: LAS PRIMERAS PRUEBAS SOLO SON SATISFACTORIAS CUANDO SE CORREN EN VERSIONES DE ARCGIS MENORES A 10.3
# ---------------------------------------------------------------------------

##################################################################################### Set the necessary product code libraries
# import os
import os
#import tkinter
import tkMessageBox

# Import arcpy module
import arcpy
import arcinfo
arcpy.CheckOutExtension("spatial")
arcpy.env.overwriteOutput = 1

tkMessageBox.showinfo(title="Enhorabuena!", message="Se ha ejecutado correctamente el BLOQUE #1 del código para generación de perfiles en laderas!")
##############################################################################################################################
#----------------------------------------------BLOQUE #2---------------------------------------------------------------------#
##############################################################################################################################

############################################################################################################## Script arguments
Modelo_de_Elevacion_digital = raw_input(u'Indique la ubicación del modelo digital de elevación de la zona de estudio: ')
DEM = arcpy.Raster(Modelo_de_Elevacion_digital)

Cota_de_elevacion_Max__de_la_zona = DEM.maximum
print('Cota Maxima de la zona: '+ str(Cota_de_elevacion_Max__de_la_zona))

Workspace = raw_input(u'Indique la ruta de almacenamiento de los productos a generar ')
arcpy.env.workspace = Workspace
Pendiente_Max__en_zonas_planas = raw_input(u'Indique un valor de pendiente máx para las zonas que se considerarán planas ')

Valor_de_acumulacion_de_drenajes = raw_input(u'Si desea indique un valor de acumulación de drenajes.\nDe lo contrario se asignará el valor por defecto (750) ')
if Valor_de_acumulacion_de_drenajes == '#' or not Valor_de_acumulacion_de_drenajes:
    Valor_de_acumulacion_de_drenajes = "750" # provide a default value if unspecified
Valor_de_acumulacion_de_drenajes = float(Valor_de_acumulacion_de_drenajes)

AMC = raw_input(u'Si desea indique un valor para el área minima cartografiable según la escala de su estudio.\nDe lo contrario se indicará el valor por defecto (10.000m2) ')
if AMC == '#' or not AMC:
    AMC = "10000" # provide a default value if unspecified
AMC = float(AMC)

DistPerfiles = raw_input(u'Si desea indique una distacia de separación en m entre los perfiles a generar.\nDe lo contrario se indicará el valor por defecto (cada 1500 m) ')
if DistPerfiles == '#' or not DistPerfiles:
    DistPerfiles = "1500" # provide a default value if unspecified
DistPerfiles = float(DistPerfiles)

tkMessageBox.showinfo(title="Enhorabuena!", message="Se ha ejecutado correctamente el BLOQUE #2 del código para generación de perfiles en laderas!")
##############################################################################################################################
#----------------------------------------------BLOQUE #3---------------------------------------------------------------------#
##############################################################################################################################

# Local variables:
DEM_INVERSO = Workspace+"\\Dem_INV"
Fill_inver = Workspace+"\\Fill_inver"
Output_drop_raster__2_ = ""
FlowDir_inver = Workspace+"\\FlowDir_inver"
FlowAcc_inver = Workspace+"\\FlowAcc_inver"
Acc2_inver = Workspace+"\\Acc2_inver"
SL_inver = Workspace+"\\sl_inver"
SOl_inver = Workspace+"\\SOl_inver"
Fill__3_ = Workspace+"\\Fill"
FD = Workspace+"\\FD"
Flow_Acc = Workspace+"\\Flow_Acc"
Acum2 = Workspace+"\\Acum2"
SLink = Workspace+"\\SLink"
Orden = Workspace+"\\Orden"
Output_drop_raster = ""
lines2 = Workspace+"\\Drenajes.shp"
Puntos_shp = Workspace+"\\Puntos.shp"
CUENCAS_DEM = Workspace+"\\CUENCAS_DEM"
CUENCAS_D_shp = Workspace+"\\CUENCAS_D.shp"
lines2_shp = Workspace+"\\lines2.shp"
Points_inver_shp = Workspace+"\\Points_inver.shp"
Cuencas_Inver = Workspace+"\\Cuencas_Inver"
Cuencas_Inversas_shp = Workspace+"\\Cuencas_Inversas.shp"
Laderas_shp = Workspace+"\\Laderas.shp"
Laderas_F2 = Laderas_shp
Laderas_F3 = Laderas_F2
Slope_Map = Workspace+"/Slope"
zonas_planas = Workspace+"/zonas_planas"
Maj_Slope = Workspace+"/Maj_Slope"
Zonal_Statis = Workspace+"/Zonal_Statis"
Laderas_slope = Workspace+"/Laderas_slope"
Lad_Slop_Uni_shp = Workspace+"/Lad_Slop_Uni.shp"
Laderas_Limpias_v2 = Workspace+"\MorfologiaV2.shp"
Laderas_Generadas = Workspace+"\LaderasArcPy.shp"
CUENCAS_Buffer = Workspace+"\CuencasBufferNeg.shp"
Cuencas_Lineas = Workspace+"\CuencasEnLineas.shp"
PuntosPerfiles = Workspace+"\PuntosPerfiles.shp"
fd_resam = Workspace+"\FDResample.tif"
ZonalSt = Workspace+"\FDLadera.tif"
Reclass_Zona2 = Workspace+"\AngulosLadera"
LaderasDir = Workspace+"\LaderasDIR"
Laderas_Generadas2 = Workspace+"\LaderasDEFIN"
Cuencas_Lineas_Partidas = Workspace+"\Cuencas_Partid.shp"
Cuencas_Lineas_Partidas2 = Workspace+"\Cuencas_Partid2.shp"
LaderasConDirecciones = Workspace+"\LadDirec.tif"
LaderasConAngulos = Workspace+"\LadAngul.tif"
LaderasAngulosShp = Workspace+"\LadAngul.shp"
PuntosConDir = Workspace+"\PuntosDir.shp"
lineasDireccionadas = Workspace+"\LineasDir.shp"
LaderasBufferNegativo = Workspace+"\LadBufNeg.shp"
LineasLaderasBuffer = Workspace+"\LnLadBufNeg.shp"
LineasDeLlegadaDePerfiles = Workspace+"\LnLlegada.shp"
PuntosConDirTabla = Workspace+"\Tabla"
##arcpy.CreateFileGDB_management(Workspace, "Lineas")
LaderaCorriendo = Workspace+"\LaderaEjec.shp"
LaderaCorriendoLinea = Workspace+"\LadEjecLin.shp"
MergeTemporal = Workspace+"\MergeTemporal.shp"
PerfilesListosEnTeoria = Workspace+"\Perfiles.shp"
PerfilesCumplen = Workspace+"\PerfilesCumplen.shp"
PerfilesCompletamenteContenidos = Workspace+"\PerfilesV2.shp"
PerfilesVersionFinal = Workspace+"\PerfilesVF.shp"
PuntosConElevacion = Workspace+"\PuntosZ.shp"
DEM_Project = Workspace+"\\Dem_PRO"

tkMessageBox.showinfo(title="Enhorabuena!", message="Se ha ejecutado correctamente el BLOQUE #3 del código para generación de perfiles en laderas!")
##############################################################################################################################
#----------------------------------------------BLOQUE #4---------------------------------------------------------------------#
##############################################################################################################################

# Process: Calculo de DEM inverso
DEM_INVERSO = DEM *(-1) + float(Cota_de_elevacion_Max__de_la_zona)

# Process: Fill (2)
arcpy.gp.Fill_sa(DEM_INVERSO, Fill_inver, "")

# Process: Flow Direction (2)
arcpy.gp.FlowDirection_sa(Fill_inver, FlowDir_inver, "NORMAL", Output_drop_raster__2_)

# Process: Flow Accumulation (2)
FlowAcc_inver = arcpy.gp.FlowAccumulation_sa(FlowDir_inver, FlowAcc_inver, "", "FLOAT")
arcpy.CopyRaster_management(FlowAcc_inver,'FlowAcc_inver.tif')
FlowAcc_inver = arcpy.Raster(Workspace+"\\FlowAcc_inver.tif")

# Process: Raster Calculator (3)
Acc2_inver = arcpy.sa.Con(FlowAcc_inver>Valor_de_acumulacion_de_drenajes, 1)

# Process: Stream Link (2)
arcpy.gp.StreamLink_sa(Acc2_inver, FlowDir_inver, SL_inver)

# Process: Stream Order (2)
arcpy.gp.StreamOrder_sa(Acc2_inver, FlowDir_inver, SOl_inver, "STRAHLER")

# Process: Fill
arcpy.gp.Fill_sa(Modelo_de_Elevacion_digital, Fill__3_, "")

# Process: Flow Direction
arcpy.gp.FlowDirection_sa(Fill__3_, FD, "NORMAL", Output_drop_raster)
arcpy.CopyRaster_management(FD,'Flow_Dir.tif')
Flow_Dir = arcpy.Raster(Workspace+"\\Flow_Dir.tif")

# Process: Flow Accumulation
##Flow_Acc = arcpy.gp.FlowAccumulation_sa(FD)
##for i in range(1):
Flow_Acc = arcpy.gp.FlowAccumulation_sa(FD)
arcpy.CopyRaster_management(Flow_Acc,'Flow_Acc.tif')
Flow_Acc = arcpy.Raster(Workspace+"\\Flow_Acc.tif")

# Process: Raster Calculator
Acum2 = arcpy.sa.Con(Flow_Acc>Valor_de_acumulacion_de_drenajes,1)

# Process: Stream Link
arcpy.gp.StreamLink_sa(Acum2, FD, SLink)

# Process: Stream Order
arcpy.gp.StreamOrder_sa(Acum2, FD, Orden, "STRAHLER")

# Process: Stream to Feature
arcpy.gp.StreamToFeature_sa(Acum2, arcpy.Raster(FD), lines2, "SIMPLIFY")

# Process: Feature Vertices To Points
arcpy.FeatureVerticesToPoints_management(lines2, Puntos_shp, "END")

# Process: Watershed
arcpy.gp.Watershed_sa(FD, Puntos_shp, CUENCAS_DEM, "ORIG_FID")

# Process: Raster to Polygon (2)
arcpy.RasterToPolygon_conversion(CUENCAS_DEM, CUENCAS_D_shp, "SIMPLIFY", "VALUE")

# Process: Stream to Feature (2)
arcpy.gp.StreamToFeature_sa(Acc2_inver, FlowDir_inver, lines2_shp, "SIMPLIFY")

# Process: Feature Vertices To Points (2)
arcpy.FeatureVerticesToPoints_management(lines2_shp, Points_inver_shp, "END")

# Process: Watershed (2)
arcpy.gp.Watershed_sa(FlowDir_inver, Points_inver_shp, Cuencas_Inver, "ORIG_FID")

# Process: Raster to Polygon
arcpy.RasterToPolygon_conversion(Cuencas_Inver, Cuencas_Inversas_shp, "SIMPLIFY", "VALUE")

# Process: Intersect
##arcpy.Intersect_analysis(Workspace+"\\CUENCAS_D.shp #;%Workspace%\\Cuencas_Inversas.shp #", Laderas_shp, "ONLY_FID", "", "INPUT")
arcpy.Intersect_analysis([Cuencas_Inversas_shp,CUENCAS_D_shp],Laderas_shp, "ONLY_FID", "", "INPUT")

# Process: Campo Morfologia
arcpy.AddField_management(Laderas_shp, "Morfologia", "TEXT", "", "", "", "", "NULLABLE", "NON_REQUIRED", "")

# Process: Asignación como laderas
arcpy.CalculateField_management(Laderas_F2, "Morfologia", "\"Ladera\"", "VB", "")

# Process: Mapa de Pendientes
arcpy.Slope_3d(Modelo_de_Elevacion_digital, Slope_Map, "DEGREE", "1")

# Process: Zonas Planas
listPlanas = [0]
listPlanas.append(float(Pendiente_Max__en_zonas_planas))
listPlanas.append(0)
listPlanas=[listPlanas]
listPlanas.append([float(Pendiente_Max__en_zonas_planas),90,1])
remap = arcpy.sa.RemapRange(listPlanas)
enterolimite = int(Pendiente_Max__en_zonas_planas)
remap = "0 " + str(enterolimite)  + " 0;" + str(enterolimite) + " 90 1"
##arcpy.Reclassify_3d(Slope_Map, "VALUE", "0 10 0;10 90 1", zonas_planas, "NODATA")
arcpy.Reclassify_3d(Slope_Map, "VALUE", remap, zonas_planas, "NODATA")

# Process: Majority Filter
arcpy.gp.MajorityFilter_sa(zonas_planas, Maj_Slope, "EIGHT", "MAJORITY")

# Process: Zonal Statistics
arcpy.gp.ZonalStatistics_sa(Laderas_shp, "FID", Maj_Slope, Zonal_Statis, "MEAN", "NODATA")

# Process: Planicies segun pendiente
arcpy.Reclassify_3d(Zonal_Statis, "VALUE", "0 0.600000 1;0.600000 1 NODATA", Laderas_slope, "NODATA")

# Process: Raster to Polygon (3)
arcpy.RasterToPolygon_conversion(Laderas_slope, Lad_Slop_Uni_shp, "SIMPLIFY", "VALUE")

# Process: Laderas - Planos (2)
arcpy.Erase_analysis(Laderas_F3, Lad_Slop_Uni_shp, Laderas_Limpias_v2, "")

# Process: Eliminar Areas menores a las indicadas

arcpy.AddField_management(Laderas_Limpias_v2,"area","Double")
expression1 = "{0}".format("!SHAPE.area@SQUAREMETERS!")
arcpy.CalculateField_management(Laderas_Limpias_v2, "area", expression1, "PYTHON", )
x = AMC
query = " \"area\" > {0} ".format(x)
arcpy.Select_analysis(Laderas_Limpias_v2, Laderas_Generadas, query)

tkMessageBox.showinfo(title="Enhorabuena!", message="Se ha ejecutado correctamente el BLOQUE #4 del código para generación de perfiles en laderas!")
##############################################################################################################################
#----------------------------------------------BLOQUE #5---------------------------------------------------------------------#
##############################################################################################################################

# Process: Buffer
arcpy.Buffer_analysis(CUENCAS_D_shp, CUENCAS_Buffer, "-1 Meters")

# Process: Polygon To Line
arcpy.PolygonToLine_management(CUENCAS_Buffer, Cuencas_Lineas, "IDENTIFY_NEIGHBORS")

# Process: Densify (Creación de vertices para puntos de perfil)
arcpy.Densify_edit(Cuencas_Lineas, "DISTANCE", DistPerfiles)

#Split lines para PuntosPerfiles2

arcpy.SplitLine_management(Cuencas_Lineas, Cuencas_Lineas_Partidas)

# Process: Eliminar Lineas muy pequeñas

arcpy.AddField_management(Cuencas_Lineas_Partidas,"Long","Double")
expression1 = "{0}".format("!SHAPE.length@METERS!")
arcpy.CalculateField_management(Cuencas_Lineas_Partidas, "Long", expression1, "PYTHON" )
x = 20
query = " \"Long\" > {0} ".format(x)
arcpy.Select_analysis(Cuencas_Lineas_Partidas, Cuencas_Lineas_Partidas2, query)

# Process: Feature Vertices To Points

arcpy.FeatureVerticesToPoints_management(Cuencas_Lineas_Partidas2, PuntosPerfiles, "MID")

### Process: Zonal Statistics (2) Flow direction por ladera
##
##arcpy.gp.ZonalStatistics_sa(Laderas_Generadas, "FID", FlujosPorLadera, fd_zonal, "MAJORITY", "DATA")

# Process: Resample
arcpy.Resample_management(FD, fd_resam, "0.5", "NEAREST")

# Process: Extract By Mask
FlujosPorLadera = arcpy.sa.ExtractByMask(fd_resam,Laderas_Generadas)

# Process: Zonal Statistics (2) Flow direction por ladera

arcpy.gp.ZonalStatistics_sa(Laderas_Generadas, "FID", FlujosPorLadera, LaderasConDirecciones, "MAJORITY", "DATA")

# Process: Reclassify (3)
arcpy.gp.Reclassify_sa(LaderasConDirecciones, "Value", "1 90;2 135;4 180;8 225;16 270;32 315;64 0;128 45", LaderasConAngulos, "DATA")

# Process: Raster to Polygon
arcpy.RasterToPolygon_conversion(LaderasConAngulos, LaderasAngulosShp, "SIMPLIFY", "Value")

# Process: Intersect
arcpy.Intersect_analysis([LaderasAngulosShp,PuntosPerfiles], PuntosConDir, "NO_FID","","POINT")

tkMessageBox.showinfo(title="Enhorabuena!", message="Se ha ejecutado correctamente el BLOQUE #5 del código para generación de perfiles en laderas!")
##############################################################################################################################
#----------------------------------------------BLOQUE #6---------------------------------------------------------------------#
##############################################################################################################################

#Process: Calulo de los campos necesarios para la tabla que se pasa al bearing distance to line
arcpy.AddField_management(PuntosConDir,"Dist","Double")
arcpy.CalculateField_management(PuntosConDir, field="Dist", expression="10", expression_type="VB", code_block="")
#### X calculo de coordenadas en grados decimales
arcpy.AddField_management(PuntosConDir,"Xi","Double")
arcpy.CalculateField_management(PuntosConDir, "Xi", "!SHAPE.CENTROID.X!","PYTHON_9.3")


#### Y calculo de coordenadas en grados decimales
arcpy.AddField_management(PuntosConDir,"Yi","Double")
arcpy.CalculateField_management(PuntosConDir, "Yi", "!SHAPE.CENTROID.Y!","PYTHON_9.3")

###Process: Generación de la tabla que se pasa al bearing distance to line
##arcpy.MakeTableView_management(PuntosConDir, PuntosConDirTabla, where_clause="", workspace="", field_info="FID ID_Punto VISIBLE NONE;Shape Shape HIDDEN NONE;Id ID_Ladera VISIBLE NONE;gridcode gridcode VISIBLE NONE;LEFT_FID LEFT_FID HIDDEN NONE;RIGHT_FID RIGHT_FID HIDDEN NONE;Long Long HIDDEN NONE;ORIG_FID ORIG_FID HIDDEN NONE;X X VISIBLE NONE;Y Y VISIBLE NONE;Dist Dist VISIBLE NONE")

#Process: Bearing distance to line
arcpy.BearingDistanceToLine_management(PuntosConDir, lineasDireccionadas, x_field="Xi", y_field="Yi", distance_field="Dist", distance_units="METERS", bearing_field="gridcode", bearing_units="DEGREES", line_type="GEODESIC", id_field="Id")

#Process: Buffer negativo a laderas
arcpy.Buffer_analysis(Laderas_Generadas, LaderasBufferNegativo, buffer_distance_or_field="-1 Meters")

#Process: Laderas a Lineas
arcpy.FeatureToLine_management(LaderasBufferNegativo, LineasLaderasBuffer, cluster_tolerance="", attributes="ATTRIBUTES")

#Process: Erase (Borrando los filos)
arcpy.Erase_analysis(LineasLaderasBuffer, Cuencas_Lineas, LineasDeLlegadaDePerfiles, cluster_tolerance="")

#Codigo para conseguir que las lineas direccionales se intersequen con las lineas de llegada según la pagina web: https://gis.stackexchange.com/questions/294404/extend-lines-to-nearest-feature

#Generar ID para laderas con Buffer Negativo
arcpy.AddField_management(LaderasBufferNegativo,"ID_NEW","Double")

codeblock = """
rec=0
def autoIncrement():
    global rec
    pStart = 1
    pInterval = 1
    if (rec == 0):
        rec = pStart
    else:
        rec += pInterval
    return rec
"""
arcpy.CalculateField_management(in_table=LaderasBufferNegativo, field="ID_NEW", expression="autoIncrement()", expression_type="PYTHON", code_block= codeblock)



#Vamos a movernos por laderas:
path = os.path.join(Workspace, "LineasPerfiles")
os.mkdir(path)
rec = int(arcpy.GetCount_management(LaderasBufferNegativo).getOutput(0))
for i in range (0,rec):
##########################################OJO NO ESTÁ SELECCIONANDO LINEAS DIRECCIONADAS CON WITHIN PORQUE SON LINEAS LAS LADERAS
    #Extraemos cada ladera
    field_area = "ORIG_FID"
    where_clause = '{} = {}'.format(arcpy.AddFieldDelimiters(LineasLaderasBuffer, field_area), i)
    arcpy.Select_analysis(LineasLaderasBuffer, LaderaCorriendoLinea, where_clause)

    #Select layer by location
    # First, make a layer from the feature class
    arcpy.MakeFeatureLayer_management(lineasDireccionadas, "lineasDir_lyr")
    # Then add a selection to the layer based on location to features in another feature class
    arcpy.SelectLayerByLocation_management ("lineasDir_lyr", "INTERSECT", LaderaCorriendoLinea)

##    #Ladera a Linea
##    arcpy.FeatureToLine_management(LaderaCorriendo, LaderaCorriendoLinea)

    #Merge
    arcpy.Merge_management([LaderaCorriendoLinea, "lineasDir_lyr"], MergeTemporal)

    #Extend_Lines
    arcpy.ExtendLine_edit(MergeTemporal, length="", extend_to="FEATURE")

    #Erase

    arcpy.Erase_analysis(MergeTemporal,LaderaCorriendoLinea,path+"\lin"+str(i)+".shp")

#Merge de las lineas de perfil generadas
arcpy.env.workspace = path
fcs = arcpy.ListFeatureClasses('*.shp')
arcpy.env.workspace = Workspace

file_paths = []

for root, dirs, files in os.walk(path):
    for file in files:
        if file.endswith(".shp"):
             print(os.path.join(root, file))
             file_paths.append(os.path.join(root, file))

arcpy.Merge_management(file_paths, PerfilesListosEnTeoria)

#Seleccionar perfiles que van de filo a valle exclusivamente
# First, make a layer from the feature class
arcpy.MakeFeatureLayer_management(PerfilesListosEnTeoria, "PerfilesListos_lyr")
arcpy.SelectLayerByLocation_management("PerfilesListos_lyr","BOUNDARY_TOUCHES",LineasDeLlegadaDePerfiles,search_distance="#",selection_type="NEW_SELECTION")

#Extraemos los perfiles que cumplen la condición
arcpy.Select_analysis("PerfilesListos_lyr",PerfilesCumplen,where_clause="#")

#Añadiendo y eliminando campos en los perfiles
arcpy.DeleteField_management(PerfilesCumplen,drop_field="FID_LadBuf;FID_cuenca;FID_cuen_1;Morfologia;area;BUFF_DIST;ORIG_FID;ID_NEW")
#Process: Calulo de los campos necesarios para LOS PERFILES RESULTANTES

arcpy.CalculateField_management(PerfilesCumplen, "Dist", "!shape.length@meters!","PYTHON_9.3")
#### X calculo de coordenadas punto final en grados decimales
arcpy.AddField_management(PerfilesCumplen,"Xf","Double")
arcpy.CalculateField_management(PerfilesCumplen, "Xf", "!Shape!.positionAlongLine(1.0,True).firstPoint.X","PYTHON_9.3")
#### Y calculo de coordenadas punto final en grados decimales
arcpy.AddField_management(PerfilesCumplen,"Yf","Double")
arcpy.CalculateField_management(PerfilesCumplen, "Yf", "!Shape!.positionAlongLine(1.0,True).firstPoint.Y","PYTHON_9.3")

#Depurar con perfiles que no intersequen laderas y que estén completamente contenidos
#arcpy.SpatialJoin_analysis(join_operation="JOIN_ONE_TO_MANY",join_type="KEEP_COMMON",field_mapping="""Dist "Dist" true true false 8 Double 0 0 ,First,#,PerfilesCumplen,Dist,-1,-1;Xi "Xi" true true false 8 Double 0 0 ,First,#,PerfilesCumplen,Xi,-1,-1;Yi "Yi" true true false 8 Double 0 0 ,First,#,PerfilesCumplen,Yi,-1,-1;Xf "Xf" true true false 8 Double 0 0 ,First,#,PerfilesCumplen,Xf,-1,-1;Yf "Yf" true true false 8 Double 0 0 ,First,#,PerfilesCumplen,Yf,-1,-1;ID_NEW "ID_NEW" true true false 19 Double 0 0 ,First,#,LadBufNeg,ID_NEW,-1,-1""",match_option="WITHIN",search_radius="#",distance_field_name="#")
arcpy.SpatialJoin_analysis(PerfilesCumplen,LaderasBufferNegativo,PerfilesCompletamenteContenidos,join_operation="JOIN_ONE_TO_MANY",join_type="KEEP_ALL",match_option="WITHIN",search_radius="#",distance_field_name="#")
arcpy.DeleteField_management(PerfilesCompletamenteContenidos,drop_field="Join_Count;TARGET_FID;JOIN_FID;ID;GRIDCODE;Morfologia;area;BUFF_DIST;ORIG_FID")
arcpy.Select_analysis(PerfilesCompletamenteContenidos,PerfilesVersionFinal,where_clause="ID_NEW <> 0")
# Process: Densify (Creación de vertices para puntos de perfil)
ResolucionRaster = arcpy.GetRasterProperties_management(DEM, "CELLSIZEX")
ResRaster = ResolucionRaster.getOutput(0)
arcpy.Densify_edit(PerfilesVersionFinal, "DISTANCE", ResRaster)

tkMessageBox.showinfo(title="Enhorabuena!", message="Se ha ejecutado correctamente el BLOQUE #6 del código para generación de perfiles en laderas!")
##############################################################################################################################
#----------------------------------------------BLOQUE #7---------------------------------------------------------------------#
##############################################################################################################################

#Sacamos puntos cada x distancia para extraer los valores z
arcpy.FeatureVerticesToPoints_management(PerfilesVersionFinal, PuntosConElevacion)

#Process: Calulo de las coordenadas de los puntos

#### X calculo de coordenadas en grados decimales
arcpy.AddField_management(PuntosConElevacion,"X","Double")
arcpy.CalculateField_management(PuntosConElevacion, "X", "!SHAPE.CENTROID.X!","PYTHON_9.3")

#### Y calculo de coordenadas en grados decimales
arcpy.AddField_management(PuntosConElevacion,"Y","Double")
arcpy.CalculateField_management(PuntosConElevacion, "Y", "!SHAPE.CENTROID.Y!","PYTHON_9.3")

#### Z calculo de la elevación en metros
#arcpy.AddField_management(PuntosConElevacion,"Z","Double")
arcpy.CheckOutExtension("3D")
##spatial_ref = arcpy.Describe(PuntosConElevacion).spatialReference
##arcpy.ProjectRaster_management(DEM,DEM_Project,spatial_ref)
##arcpy.AddSurfaceInformation_3d(PuntosConElevacion,DEM,out_property="Z")
arcpy.AddSurfaceInformation_3d(in_feature_class=PuntosConElevacion,in_surface=DEM,out_property="Z",method="BILINEAR",sample_distance="#",z_factor="1",pyramid_level_resolution="0",noise_filtering="NO_FILTER")
tkMessageBox.showinfo(title="Enhorabuena!", message="Se ha ejecutado correctamente el BLOQUE #7 del código para generación de perfiles en laderas!")



# Deleting unnecesary files

os.unlink(CUENCAS_DEM)
print("CUENCAS_DEM Removed!")
os.remove(Cuencas_Inver)
print("Cuencas_Inver Removed!")
os.remove(FD)
print("FD Removed!")
os.remove(Fill__3_)
print("Fill Removed!")
os.remove(Fill_inver)
print("Fill_inver Removed!")
os.remove(Flow_Acc)
print("Flow_Acc Removed!")
os.remove(Flow_Dir)
print("Flow_Dir Removed!")
os.remove(Workspace+"\FlowAcc_fd1.tif")
print("FlowAcc_fd1.tif Removed!")
os.remove(Workspace+"\FlowAcc_fd1.tif")
print("flowacc_inver Removed!")
os.remove(Workspace+"FlowAcc_inver.tif")
print("FlowAcc_inver.tif Removed!")
os.remove(FlowDir_inver)
print("FlowDir_inver Removed!")
os.remove(Workspace+"ifthe_ras.tif")
print("ifthe_ras.tif Removed!")
os.remove(Workspace+"ifthe_ras1.tif")
print("ifthe_ras1 Removed!")
os.remove(Lad_Slop_Uni_shp)
print("Lad_Slop_Uni_shp Removed!")
os.remove(Laderas_shp)
print("Laderas_shp Removed!")
os.remove(Laderas_slope)
print("Laderas_slope Removed!")
os.remove(Workspace+"\\lines2.shp")
print("lines2 Removed!")
os.remove(Maj_Slope)
print("Maj_Slope Removed!")
os.remove(Workspace+"plus_ras.tif")
print("plus_ras.tif Removed!")
os.remove(Points_inver_shp)
print("Points_inver_shp Removed!")
os.remove(Puntos_shp)
print("Puntos_shp Removed!")
os.remove(SL_inver)
print("SL_inver Removed!")
os.remove(SLink)
print("SLink Removed!")
os.remove(SOl_inver)
print("SOl_inver Removed!")
os.remove(Workspace+"t_t6816.tif")
print("t_t6816.tif Removed!")
os.remove(Zonal_Statis)
print("Zonal_Statis Removed!")
os.remove(zonas_planas)
print("zonas_planas Removed!")